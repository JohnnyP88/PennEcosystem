# -*- coding: utf-8 -*-
"""Network Viz.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1V02VdY7OvR87miM_B9GtD320cy_hRfdP

https://programminghistorian.org/en/lessons/exploring-and-analyzing-network-data-with-python

#Import Libraries
"""

# !pip install pyvis
# !pip install Network
# !pip install TapTool

import pandas as pd
import networkx
# !pip install bokeh
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
# from bokeh.io import output_notebook, show, save
from bokeh.models import Range1d, Circle, ColumnDataSource, MultiLine
from bokeh.plotting import figure, curdoc, from_networkx
from bokeh.models import EdgesAndLinkedNodes, NodesAndLinkedEdges, LabelSet
from bokeh.palettes import Blues8, Spectral8
from bokeh.transform import linear_cmap
from networkx.algorithms import community

"""#Data Loading"""

df = pd.read_csv("network.csv")
# df.head()
print("reading data")
df.rename(columns={'domains_clean':'source', 'embedded_domains':'target', 'embedded_domains.1':'weight'}, inplace=True)

df = df[df['target']!='None']
df['source'] = df['source'].apply(lambda x: x.replace('.upenn.edu',''))
df['target'] = df['target'].apply(lambda x: x.replace('.upenn.edu',''))

df_cat = pd.read_excel("site_domainV2.xlsx")
df_cat['Category'] = df_cat[['R&D','Teaching','Organizer', 'Knowledge', 'Media']].apply(lambda x: ','.join(x[x.isnull()==False].index), axis=1)
df_cat['domains'] = df_cat['domain'].apply(lambda x: x.split('/')[2].replace('www.','').replace('.upenn.edu',''))

url_class = dict(zip(df_cat['domains'],df_cat['domain']))
category_class = dict(zip(df_cat['domains'],df_cat['Category']))
df['source_category'] = df.merge(df_cat, how='left', left_on='source', right_on='domains')['Category']
df['target_category'] = df.merge(df_cat, how='left', left_on='target', right_on='domains')['Category']


"""#Network(interactive)"""
from bokeh.core.enums import SizingMode
from bokeh.io import show
from bokeh.models import CustomJS, MultiChoice
from bokeh.io.output import output_file
from bokeh.models import Button, CustomJS, Div, CheckboxButtonGroup, TapTool, OpenURL
from bokeh.plotting import figure
from bokeh.layouts import column, row
from bokeh.models import CDSView, ColumnDataSource, GroupFilter
from bokeh.io import show
from networkx.algorithms import community

#Choose colors for node and edge highlighting
node_highlight_color = 'white'
edge_highlight_color = 'black'

#Choose attributes from G network to size and color by — setting manual size (e.g. 10) or color (e.g. 'skyblue') also allowed
size_by_this_attribute = 'adjusted_node_size'
color_by_this_attribute = 'modularity_color'

#Pick a color palette — Blues8, Reds8, Purples8, Oranges8, Viridis8
color_palette = Blues8

#Choose a title!
title = 'Mapping PIE'

#Establish which categories will appear when hovering over each node
HOVER_TOOLTIPS = [
    ("Character", "@index"),
    ("Degree", "@degree"),
    ("Modularity Class", "@modularity_class"),
    ("Modularity Color", "$color[swatch]:modularity_color"),
    ("URL", "@URL"),
    ("category", "@category")
]

#Create a plot — set dimensions, toolbar, and title
plot = figure(tooltips = HOVER_TOOLTIPS,
              tools="pan,wheel_zoom,save,reset,tap", active_scroll='wheel_zoom',
              x_range=Range1d(-15.1, 15.1), y_range=Range1d(-15.1, 15.1), 
              plot_width=1000, 
              title=title)


labels = ["R&D", "Teaching", "Organizer", "Knowledge", "Media"]
## Source
source_cat = Div(text="Select Source Category")
source_checkbox_button_group = CheckboxButtonGroup(labels=labels, active=[0])
source_select_all = Button(label='Select All')
source_select_none = Button(label='Select none')
# source_RD = df[df["source_category"].str.contains("R&D")==True]
# source_Teaching = df[df["source_category"].str.contains("Teaching")==True]
# source_Organizer = df[df["source_category"].str.contains("Organizer")==True]
# source_Knowledge = df[df["source_category"].str.contains("Knowledge")==True]
# source_Media = df[df["source_category"].str.contains("Media")==True]
# G1 = networkx.from_pandas_edgelist(source_RD, 'source', 'target', edge_attr=['weight'], create_using=nx.DiGraph())
# G2 = networkx.from_pandas_edgelist(source_Teaching, 'source', 'target', edge_attr=['weight'], create_using=nx.DiGraph())
# G3 = networkx.from_pandas_edgelist(source_Organizer, 'source', 'target', edge_attr=['weight'], create_using=nx.DiGraph())
# G4 = networkx.from_pandas_edgelist(source_Knowledge, 'source', 'target', edge_attr=['weight'], create_using=nx.DiGraph())
# G5 = networkx.from_pandas_edgelist(source_Media, 'source', 'target', edge_attr=['weight'], create_using=nx.DiGraph())
# selected_nodes = [n for n,v in G.nodes(data=True) if v['since'] == 'December 2008']  
# args = [('checkbox_source', source_checkbox_button_group)]
# code = "var active = cb_obj.active;"
# for c in range(len(LABELS)):
#     network = networkx.from_pandas_edgelist(G, 'source', 'target', edge_attr=['weight'], create_using=nx.DiGraph())
#     line = p.line(x='dates', y=currencies[c], line_width=2, alpha=1, name=currencies[c], legend_label=currencies[c], source=source)
#     args += [('line'+str(c), line)]
#     code += "line{}.visible = active.includes({});".format(c, c)
source=df
source_select_all.js_on_click(CustomJS(args={'checkbox_group': source_checkbox_button_group, 'labels': labels}, code="checkbox_group.active = Array.from(labels, (x, i) => i);"))
source_select_none.js_on_click(CustomJS(args={'checkbox_group': source_checkbox_button_group}, code="checkbox_group.active = [];"))
def callback(attr, old, new):
    new_plot = figure(tooltips = HOVER_TOOLTIPS,
              tools="pan,wheel_zoom,save,reset,tap", active_scroll='wheel_zoom',
              x_range=Range1d(-15.1, 15.1), y_range=Range1d(-15.1, 15.1), 
              plot_width=1000, 
              title=title)
    source_selected = [source_checkbox_button_group.labels[i] for i in source_checkbox_button_group.active]
    target_selected = [target_checkbox_button_group.labels[i] for i in target_checkbox_button_group.active]
    print("source",source_selected)
    print("target",target_selected)
    source =  df[(df["target_category"].isin(target_selected)) & (df['source_category'].isin(source_selected))]
    # # new_data = dict()
    # # new_x = filtered["Year"].unique()
    # # new_y = filtered.groupby("Year")["Value"].sum().values
    # # new_data["x"] = new_x
    # # new_data["y"] = new_y
    print("updated",source)
    G = networkx.from_pandas_edgelist(source, 'source', 'target', edge_attr=['weight'], create_using=networkx.DiGraph())

    #Calculate degree for each node and add as node attribute
    degrees = dict(networkx.degree(G))
    networkx.set_node_attributes(G, name='degree', values=degrees)

    #Slightly adjust degree so that the nodes with very small degrees are still visible
    number_to_adjust_by = 5
    adjusted_node_size = dict([(node, degree+number_to_adjust_by) for node, degree in networkx.degree(G)])
    networkx.set_node_attributes(G, name='adjusted_node_size', values=adjusted_node_size)

    # communities = community.greedy_modularity_communities(G)
    # #Add modularity class and color as attributes to network graph

    # # Create empty dictionaries
    # modularity_class = {}
    # modularity_color = {}
    # #Loop through each community in the network
    # for community_number, community in enumerate(communities):
    #     #For each member of the community, add their community number and a distinct color
    #     for name in community: 
    #         modularity_class[name] = community_number
    #         modularity_color[name] = Spectral8[community_number]

    # Add modularity class, color, URLs as attributes from the network above
    networkx.set_node_attributes(G, modularity_class, 'modularity_class')
    networkx.set_node_attributes(G, modularity_color, 'modularity_color')
    networkx.set_node_attributes(G, url_class, "URL")
    networkx.set_node_attributes(G, category_class, "category")
    # Configure tap tool
    taptool = new_plot.select(type=TapTool)
    taptool.callback = OpenURL(url="@URL")
    network_graph = from_networkx(G, networkx.spring_layout, scale=15, center=(0, 0))
    #Create newnetwork graph from filtered data
    #Set node sizes and colors according to node degree (color as category from attribute)
    network_graph.node_renderer.glyph = Circle(size=size_by_this_attribute, fill_color=color_by_this_attribute)
    #Set node highlight colors
    network_graph.node_renderer.hover_glyph = Circle(size=size_by_this_attribute, fill_color=node_highlight_color, line_width=2)
    network_graph.node_renderer.selection_glyph = Circle(size=size_by_this_attribute, fill_color=node_highlight_color, line_width=2)
    #Set edge opacity and width
    network_graph.edge_renderer.glyph = MultiLine(line_alpha=0.3, line_width=1)
    #Set edge highlight colors
    network_graph.edge_renderer.selection_glyph = MultiLine(line_color=edge_highlight_color, line_width=2)
    network_graph.edge_renderer.hover_glyph = MultiLine(line_color=edge_highlight_color, line_width=2)
    #Highlight nodes and edges
    network_graph.selection_policy = NodesAndLinkedEdges()
    network_graph.inspection_policy = NodesAndLinkedEdges()
    new_plot.renderers.append(network_graph)
    #Add Labels
    x, y = zip(*network_graph.layout_provider.graph_layout.values())
    node_labels = list(G.nodes())
    label_source = ColumnDataSource({'x': x, 'y': y, 'name': [node_labels[i] for i in range(len(x))]})
    labels = LabelSet(x='x', y='y', text='name', source=label_source, background_fill_color='white', text_font_size='10px', background_fill_alpha=.8)
    new_plot.renderers.append(labels)
    # show(column(group, plot))
    # output_file('network.html')
    #save(plot, filename=f"{title}.html")
    group = row(column(source_cat, source_select_all, source_select_none, source_checkbox_button_group),
                column(target_cat, target_select_all, target_select_none, target_checkbox_button_group),
                sizing_mode='stretch_both')
    layout.children[2] = new_plot
# def source_callback(attr, old, new):
#     new_plot = figure(tooltips = HOVER_TOOLTIPS,
#               tools="pan,wheel_zoom,save,reset,tap", active_scroll='wheel_zoom',
#               x_range=Range1d(-15.1, 15.1), y_range=Range1d(-15.1, 15.1), 
#               plot_width=1000, 
#               title=title)
#     source_selected = [source_checkbox_button_group.labels[i] for i in source_checkbox_button_group.active]
#     target_selected = [target_checkbox_button_group.labels[i] for i in target_checkbox_button_group.active]
#     print("source",source_selected, target_selected)
#     source =  df[df["source_category"].isin(source_selected) and df['target_category'].isin(target_selected)]
#     # # new_data = dict()
#     # # new_x = filtered["Year"].unique()
#     # # new_y = filtered.groupby("Year")["Value"].sum().values
#     # # new_data["x"] = new_x
#     # # new_data["y"] = new_y
#     print("source",source)
#     G = networkx.from_pandas_edgelist(source, 'source', 'target', edge_attr=['weight'], create_using=networkx.DiGraph())

#     #Calculate degree for each node and add as node attribute
#     degrees = dict(networkx.degree(G))
#     networkx.set_node_attributes(G, name='degree', values=degrees)

#     #Slightly adjust degree so that the nodes with very small degrees are still visible
#     number_to_adjust_by = 5
#     adjusted_node_size = dict([(node, degree+number_to_adjust_by) for node, degree in networkx.degree(G)])
#     networkx.set_node_attributes(G, name='adjusted_node_size', values=adjusted_node_size)

#     # communities = community.greedy_modularity_communities(G)
#     # #Add modularity class and color as attributes to network graph

#     # # Create empty dictionaries
#     # modularity_class = {}
#     # modularity_color = {}
#     # #Loop through each community in the network
#     # for community_number, community in enumerate(communities):
#     #     #For each member of the community, add their community number and a distinct color
#     #     for name in community: 
#     #         modularity_class[name] = community_number
#     #         modularity_color[name] = Spectral8[community_number]

#     # Add modularity class, color, URLs as attributes from the network above
#     networkx.set_node_attributes(G, modularity_class, 'modularity_class')
#     networkx.set_node_attributes(G, modularity_color, 'modularity_color')
#     networkx.set_node_attributes(G, url_class, "URL")
#     networkx.set_node_attributes(G, category_class, "category")
#     # Configure tap tool
#     taptool = new_plot.select(type=TapTool)
#     taptool.callback = OpenURL(url="@URL")
#     network_graph = from_networkx(G, networkx.spring_layout, scale=15, center=(0, 0))
#     #Create newnetwork graph from filtered data
#     #Set node sizes and colors according to node degree (color as category from attribute)
#     network_graph.node_renderer.glyph = Circle(size=size_by_this_attribute, fill_color=color_by_this_attribute)
#     #Set node highlight colors
#     network_graph.node_renderer.hover_glyph = Circle(size=size_by_this_attribute, fill_color=node_highlight_color, line_width=2)
#     network_graph.node_renderer.selection_glyph = Circle(size=size_by_this_attribute, fill_color=node_highlight_color, line_width=2)
#     #Set edge opacity and width
#     network_graph.edge_renderer.glyph = MultiLine(line_alpha=0.3, line_width=1)
#     #Set edge highlight colors
#     network_graph.edge_renderer.selection_glyph = MultiLine(line_color=edge_highlight_color, line_width=2)
#     network_graph.edge_renderer.hover_glyph = MultiLine(line_color=edge_highlight_color, line_width=2)
#     #Highlight nodes and edges
#     network_graph.selection_policy = NodesAndLinkedEdges()
#     network_graph.inspection_policy = NodesAndLinkedEdges()
#     new_plot.renderers.append(network_graph)
#     #Add Labels
#     x, y = zip(*network_graph.layout_provider.graph_layout.values())
#     node_labels = list(G.nodes())
#     label_source = ColumnDataSource({'x': x, 'y': y, 'name': [node_labels[i] for i in range(len(x))]})
#     labels = LabelSet(x='x', y='y', text='name', source=label_source, background_fill_color='white', text_font_size='10px', background_fill_alpha=.8)
#     new_plot.renderers.append(labels)
#     # show(column(group, plot))
#     # output_file('network.html')
#     #save(plot, filename=f"{title}.html")
#     group = row(column(source_cat, source_select_all, source_select_none, source_checkbox_button_group),
#                 column(target_cat, target_select_all, target_select_none, target_checkbox_button_group),
#                 sizing_mode='stretch_both')
#     layout.children[1] = new_plot
source_checkbox_button_group.on_change('active', callback)

# data_new = df
# data_new = pd.DataFrame.from_dict(dict(source = df.source, target = df.target, weight = df.weight))
G = networkx.from_pandas_edgelist(df, 'source', 'target', edge_attr=['weight'], create_using=networkx.DiGraph())
# callback = CustomJS(args = {'checkbox':source_checkbox_button_group, 'df': df, 'data_new': data_new},
# code = """
# # console.log(df);
# var data = df.data;
# var s_data = data_new.data;
# var source_category = data['source_category'];
# var select_vals = cb_obj.active.map(x => cb_obj.labels[x]);
# console.log(select_vals);
# var x_data = data['source'];
# var y_data = data['target'];
# var x = s_data['source'];
# x.length = 0;
# var y = s_data['target'];
# y.length = 0;
# for (var i = 0; i < x_data.length; i++) {
#     if (select_vals.indexOf(source_category[i]) >= 0) {
#         x.push(x_data[i]);
#         y.push(y_data[i]);
#         }
# }
# data_new.change.emit();
# # """)
# def update(event):
# #Callback    
#     print("update triggered")
#     df.data = data
#     # create a callback that will reset the datasource


## Target
target_cat = Div(text="Select Target Category")
target_checkbox_button_group = CheckboxButtonGroup(labels=labels, active=[0, 1])
target_select_all = Button(label='Select All')
target_select_none = Button(label='Select None')
target_select_all.js_on_click(CustomJS(args={'checkbox_group': target_checkbox_button_group, 'labels': labels}, code="checkbox_group.active = Array.from(labels, (x, i) => i);"))
target_select_none.js_on_click(CustomJS(args={'checkbox_group': target_checkbox_button_group}, code="checkbox_group.active = [];"))
def target_callback(attr, old, new):
    new_plot = figure(tooltips = HOVER_TOOLTIPS,
              tools="pan,wheel_zoom,save,reset,tap", active_scroll='wheel_zoom',
              x_range=Range1d(-15.1, 15.1), y_range=Range1d(-15.1, 15.1), 
              plot_width=1000, 
              title=title)
    selected = [target_checkbox_button_group.labels[i] for i in target_checkbox_button_group.active]
    print("target",selected)
    source =  df[df["target_category"].isin(selected)]
    # # new_data = dict()
    # # new_x = filtered["Year"].unique()
    # # new_y = filtered.groupby("Year")["Value"].sum().values
    # # new_data["x"] = new_x
    # # new_data["y"] = new_y
    print("target", source)
    G = networkx.from_pandas_edgelist(source, 'source', 'target', edge_attr=['weight'], create_using=networkx.DiGraph())

    #Calculate degree for each node and add as node attribute
    degrees = dict(networkx.degree(G))
    networkx.set_node_attributes(G, name='degree', values=degrees)

    #Slightly adjust degree so that the nodes with very small degrees are still visible
    number_to_adjust_by = 5
    adjusted_node_size = dict([(node, degree+number_to_adjust_by) for node, degree in networkx.degree(G)])
    networkx.set_node_attributes(G, name='adjusted_node_size', values=adjusted_node_size)

    # communities = community.greedy_modularity_communities(G)
    # #Add modularity class and color as attributes to network graph

    # # Create empty dictionaries
    # modularity_class = {}
    # modularity_color = {}
    # #Loop through each community in the network
    # for community_number, community in enumerate(communities):
    #     #For each member of the community, add their community number and a distinct color
    #     for name in community: 
    #         modularity_class[name] = community_number
    #         modularity_color[name] = Spectral8[community_number]

    # Add modularity class, color, URLs as attributes from the network above
    networkx.set_node_attributes(G, modularity_class, 'modularity_class')
    networkx.set_node_attributes(G, modularity_color, 'modularity_color')
    networkx.set_node_attributes(G, url_class, "URL")
    networkx.set_node_attributes(G, category_class, "category")
    # Configure tap tool
    taptool = new_plot.select(type=TapTool)
    taptool.callback = OpenURL(url="@URL")
    network_graph = from_networkx(G, networkx.spring_layout, scale=15, center=(0, 0))
    #Create newnetwork graph from filtered data
    #Set node sizes and colors according to node degree (color as category from attribute)
    network_graph.node_renderer.glyph = Circle(size=size_by_this_attribute, fill_color=color_by_this_attribute)
    #Set node highlight colors
    network_graph.node_renderer.hover_glyph = Circle(size=size_by_this_attribute, fill_color=node_highlight_color, line_width=2)
    network_graph.node_renderer.selection_glyph = Circle(size=size_by_this_attribute, fill_color=node_highlight_color, line_width=2)
    #Set edge opacity and width
    network_graph.edge_renderer.glyph = MultiLine(line_alpha=0.3, line_width=1)
    #Set edge highlight colors
    network_graph.edge_renderer.selection_glyph = MultiLine(line_color=edge_highlight_color, line_width=2)
    network_graph.edge_renderer.hover_glyph = MultiLine(line_color=edge_highlight_color, line_width=2)
    #Highlight nodes and edges
    network_graph.selection_policy = NodesAndLinkedEdges()
    network_graph.inspection_policy = NodesAndLinkedEdges()
    new_plot.renderers.append(network_graph)
    #Add Labels
    x, y = zip(*network_graph.layout_provider.graph_layout.values())
    node_labels = list(G.nodes())
    label_source = ColumnDataSource({'x': x, 'y': y, 'name': [node_labels[i] for i in range(len(x))]})
    labels = LabelSet(x='x', y='y', text='name', source=label_source, background_fill_color='white', text_font_size='10px', background_fill_alpha=.8)
    new_plot.renderers.append(labels)
    # show(column(group, plot))
    # output_file('network.html')
    #save(plot, filename=f"{title}.html")
    group = row(column(source_cat, source_select_all, source_select_none, source_checkbox_button_group),
                column(target_cat, target_select_all, target_select_none, target_checkbox_button_group),
                sizing_mode='stretch_both')
    layout.children[2] = new_plot

target_checkbox_button_group.on_change('active', callback)


#Create a network graph object and filter
# view1 = combined_df[combined_df["Category"].str.contains("Teaching")==True]
# view2 = combined_df[combined_df["Category"].str.contains("R&D")==True]
# view3 = combined_df[combined_df["Category"].str.contains("Organizer")==True]
# view4 = combined_df[combined_df["Category"].str.contains("Knowledge")==True]
# view5 = df[df["source_category"].str.contains("Media")==True]
#Calculate degree for each node and add as node attribute
degrees = dict(networkx.degree(G))
networkx.set_node_attributes(G, name='degree', values=degrees)

#Slightly adjust degree so that the nodes with very small degrees are still visible
number_to_adjust_by = 5
adjusted_node_size = dict([(node, degree+number_to_adjust_by) for node, degree in networkx.degree(G)])
networkx.set_node_attributes(G, name='adjusted_node_size', values=adjusted_node_size)

communities = community.greedy_modularity_communities(G)
#Add modularity class and color as attributes to network graph

# Create empty dictionaries
modularity_class = {}
modularity_color = {}
#Loop through each community in the network
for community_number, community in enumerate(communities):
    #For each member of the community, add their community number and a distinct color
    for name in community: 
        modularity_class[name] = community_number
        modularity_color[name] = Spectral8[community_number]

# Add modularity class, color, URLs as attributes from the network above
networkx.set_node_attributes(G, modularity_class, 'modularity_class')
networkx.set_node_attributes(G, modularity_color, 'modularity_color')
networkx.set_node_attributes(G, url_class, "URL")
networkx.set_node_attributes(G, category_class, "category")
# Configure tap tool
taptool = plot.select(type=TapTool)
taptool.callback = OpenURL(url="@URL")
network_graph = from_networkx(G, networkx.spring_layout, scale=15, center=(0, 0))
#Create newnetwork graph from filtered data
#Set node sizes and colors according to node degree (color as category from attribute)
network_graph.node_renderer.glyph = Circle(size=size_by_this_attribute, fill_color=color_by_this_attribute)
#Set node highlight colors
network_graph.node_renderer.hover_glyph = Circle(size=size_by_this_attribute, fill_color=node_highlight_color, line_width=2)
network_graph.node_renderer.selection_glyph = Circle(size=size_by_this_attribute, fill_color=node_highlight_color, line_width=2)

#Set edge opacity and width
network_graph.edge_renderer.glyph = MultiLine(line_alpha=0.3, line_width=1)
#Set edge highlight colors
network_graph.edge_renderer.selection_glyph = MultiLine(line_color=edge_highlight_color, line_width=2)
network_graph.edge_renderer.hover_glyph = MultiLine(line_color=edge_highlight_color, line_width=2)

#Highlight nodes and edges
network_graph.selection_policy = NodesAndLinkedEdges()
network_graph.inspection_policy = NodesAndLinkedEdges()

plot.renderers.append(network_graph)

#Add Labels
x, y = zip(*network_graph.layout_provider.graph_layout.values())
node_labels = list(G.nodes())
label_source = ColumnDataSource({'x': x, 'y': y, 'name': [node_labels[i] for i in range(len(x))]})
labels = LabelSet(x='x', y='y', text='name', source=label_source, background_fill_color='white', text_font_size='10px', background_fill_alpha=.8)
plot.renderers.append(labels)
# print(plot)
# show(column(group, plot))
# output_file('network.html')
#save(plot, filename=f"{title}.html")
remove_school_button = Button(label="Remove Schools",  button_type='danger')
def callback_remove():
    new_plot = figure(tooltips = HOVER_TOOLTIPS,
              tools="pan,wheel_zoom,save,reset,tap", active_scroll='wheel_zoom',
              x_range=Range1d(-15.1, 15.1), y_range=Range1d(-15.1, 15.1), 
              plot_width=1000, 
              title=title)
    cat_selected = ['Media', 'Knowledge', 'R&D', 'Organizer']
    print("source",cat_selected)
    source =  df[(df["target_category"].isin(cat_selected)) & (df['source_category'].isin(cat_selected))]
    # # new_data = dict()
    # # new_x = filtered["Year"].unique()
    # # new_y = filtered.groupby("Year")["Value"].sum().values
    # # new_data["x"] = new_x
    # # new_data["y"] = new_y
    print("updated",source)
    G = networkx.from_pandas_edgelist(source, 'source', 'target', edge_attr=['weight'], create_using=networkx.DiGraph())

    #Calculate degree for each node and add as node attribute
    degrees = dict(networkx.degree(G))
    networkx.set_node_attributes(G, name='degree', values=degrees)

    #Slightly adjust degree so that the nodes with very small degrees are still visible
    number_to_adjust_by = 5
    adjusted_node_size = dict([(node, degree+number_to_adjust_by) for node, degree in networkx.degree(G)])
    networkx.set_node_attributes(G, name='adjusted_node_size', values=adjusted_node_size)

    # communities = community.greedy_modularity_communities(G)
    # #Add modularity class and color as attributes to network graph

    # # Create empty dictionaries
    # modularity_class = {}
    # modularity_color = {}
    # #Loop through each community in the network
    # for community_number, community in enumerate(communities):
    #     #For each member of the community, add their community number and a distinct color
    #     for name in community: 
    #         modularity_class[name] = community_number
    #         modularity_color[name] = Spectral8[community_number]

    # Add modularity class, color, URLs as attributes from the network above
    networkx.set_node_attributes(G, modularity_class, 'modularity_class')
    networkx.set_node_attributes(G, modularity_color, 'modularity_color')
    networkx.set_node_attributes(G, url_class, "URL")
    networkx.set_node_attributes(G, category_class, "category")
    # Configure tap tool
    taptool = new_plot.select(type=TapTool)
    taptool.callback = OpenURL(url="@URL")
    network_graph = from_networkx(G, networkx.spring_layout, scale=15, center=(0, 0))
    #Create newnetwork graph from filtered data
    #Set node sizes and colors according to node degree (color as category from attribute)
    network_graph.node_renderer.glyph = Circle(size=size_by_this_attribute, fill_color=color_by_this_attribute)
    #Set node highlight colors
    network_graph.node_renderer.hover_glyph = Circle(size=size_by_this_attribute, fill_color=node_highlight_color, line_width=2)
    network_graph.node_renderer.selection_glyph = Circle(size=size_by_this_attribute, fill_color=node_highlight_color, line_width=2)
    #Set edge opacity and width
    network_graph.edge_renderer.glyph = MultiLine(line_alpha=0.3, line_width=1)
    #Set edge highlight colors
    network_graph.edge_renderer.selection_glyph = MultiLine(line_color=edge_highlight_color, line_width=2)
    network_graph.edge_renderer.hover_glyph = MultiLine(line_color=edge_highlight_color, line_width=2)
    #Highlight nodes and edges
    network_graph.selection_policy = NodesAndLinkedEdges()
    network_graph.inspection_policy = NodesAndLinkedEdges()
    new_plot.renderers.append(network_graph)
    #Add Labels
    x, y = zip(*network_graph.layout_provider.graph_layout.values())
    node_labels = list(G.nodes())
    label_source = ColumnDataSource({'x': x, 'y': y, 'name': [node_labels[i] for i in range(len(x))]})
    labels = LabelSet(x='x', y='y', text='name', source=label_source, background_fill_color='white', text_font_size='10px', background_fill_alpha=.8)
    new_plot.renderers.append(labels)
    # show(column(group, plot))
    # output_file('network.html')
    #save(plot, filename=f"{title}.html")
    group = row(column(source_cat, source_select_all, source_select_none, source_checkbox_button_group),
                column(target_cat, target_select_all, target_select_none, target_checkbox_button_group),
                sizing_mode='stretch_both')
    layout.children[2] = new_plot

remove_school_button.on_click(callback_remove)
group = row(column(source_cat, source_select_all, source_select_none, source_checkbox_button_group),
            column(target_cat, target_select_all, target_select_none, target_checkbox_button_group),
            sizing_mode='stretch_both')
layout = column(group, remove_school_button, plot)
curdoc().add_root(layout)
# https://towardsdatascience.com/how-to-create-a-plotly-visualization-and-embed-it-on-websites-517c1a78568b



